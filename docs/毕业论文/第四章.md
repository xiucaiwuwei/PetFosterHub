# 4□系统设计与实现

本章将详细介绍PetFosterHub宠物寄养平台的系统设计与实现过程，包括数据库设计、系统模块实现、接口设计、关键算法实现以及系统集成与测试等方面。通过本章的内容，可以了解系统的具体实现细节和技术方案。

## 4.1□数据库设计

数据库设计是系统实现的重要基础，它直接影响到系统的数据存储效率、访问性能和可维护性。PetFosterHub宠物寄养平台的数据库设计包括数据库选型、数据库表结构设计、索引设计和数据库优化等方面。

### 4.1.1□数据库选型

根据系统的需求和技术栈选型，PetFosterHub宠物寄养平台选择以下数据库：

1. 主数据库：MySQL 8.0
   MySQL是一个开源的关系型数据库管理系统，它具有高性能、高可靠性、易使用等优点，适合存储结构化数据，如用户信息、宠物信息、订单信息等。MySQL 8.0是MySQL的最新版本，它带来了许多新特性和性能改进，如支持窗口函数、CTE（Common Table Expressions）、JSON增强等。

2. 缓存数据库：Redis 6.0
   Redis是一个开源的内存数据结构存储系统，它可以用作数据库、缓存和消息中间件。Redis具有高性能、高可用性、支持多种数据结构等优点，适合存储热点数据、会话数据等，如用户的登录状态、热门寄养服务列表等。Redis 6.0是Redis的最新版本，它支持多线程I/O，进一步提高了性能。

### 4.1.2□数据库表结构设计

根据系统的功能需求和业务流程，设计了以下主要的数据库表：

1. 用户表（users）
   用户表用于存储平台用户的基本信息和账号信息。

   | 字段名 | 数据类型 | 长度 | 是否主键 | 描述 |
   |--------|----------|------|----------|------|
   | id | BIGINT | 20 | 是 | 用户ID |
   | username | VARCHAR | 50 | 否 | 用户名 |
   | password | VARCHAR | 100 | 否 | 密码（加密存储） |
   | phone | VARCHAR | 20 | 否 | 手机号 |
   | email | VARCHAR | 100 | 否 | 邮箱 |
   | nickname | VARCHAR | 50 | 否 | 昵称 |
   | avatar | VARCHAR | 255 | 否 | 头像URL |
   | gender | TINYINT | 1 | 否 | 性别（0：未知，1：男，2：女） |
   | birthday | DATE |  | 否 | 生日 |
   | real_name_status | TINYINT | 1 | 否 | 实名认证状态（0：未认证，1：审核中，2：已认证，3：认证失败） |
   | id_card_no | VARCHAR | 30 | 否 | 身份证号（加密存储） |
   | real_name | VARCHAR | 50 | 否 | 真实姓名 |
   | create_time | DATETIME |  | 否 | 创建时间 |
   | update_time | DATETIME |  | 否 | 更新时间 |
   | last_login_time | DATETIME |  | 否 | 最后登录时间 |
   | status | TINYINT | 1 | 否 | 账号状态（0：正常，1：冻结） |

2. 宠物表（pets）
   宠物表用于存储用户的宠物信息。

   | 字段名 | 数据类型 | 长度 | 是否主键 | 描述 |
   |--------|----------|------|----------|------|
   | id | BIGINT | 20 | 是 | 宠物ID |
   | user_id | BIGINT | 20 | 否 | 所属用户ID |
   | name | VARCHAR | 50 | 否 | 宠物名称 |
   | type | VARCHAR | 20 | 否 | 宠物类型（如猫、狗、其他） |
   | breed | VARCHAR | 50 | 否 | 宠物品种 |
   | age | INT | 11 | 否 | 年龄（月） |
   | gender | TINYINT | 1 | 否 | 性别（0：未知，1：公，2：母） |
   | weight | DECIMAL | 10,2 | 否 | 体重（公斤） |
   | personality | VARCHAR | 255 | 否 | 性格特点 |
   | health_condition | VARCHAR | 255 | 否 | 健康状况 |
   | vaccine_status | VARCHAR | 255 | 否 | 疫苗接种情况 |
   | description | TEXT |  | 否 | 描述信息 |
   | create_time | DATETIME |  | 否 | 创建时间 |
   | update_time | DATETIME |  | 否 | 更新时间 |

3. 寄养服务表（foster_services）
   寄养服务表用于存储寄养家庭发布的寄养服务信息。

   | 字段名 | 数据类型 | 长度 | 是否主键 | 描述 |
   |--------|----------|------|----------|------|
   | id | BIGINT | 20 | 是 | 服务ID |
   | user_id | BIGINT | 20 | 否 | 所属用户ID（寄养家庭ID） |
   | service_type | VARCHAR | 20 | 否 | 服务类型（如日托、短期寄养、长期寄养） |
   | price | DECIMAL | 10,2 | 否 | 服务价格（元/天） |
   | start_time | DATETIME |  | 否 | 服务开始时间 |
   | end_time | DATETIME |  | 否 | 服务结束时间 |
   | max_pet_num | INT | 11 | 否 | 可接受的最大宠物数量 |
   | accept_pet_type | VARCHAR | 100 | 否 | 可接受的宠物类型 |
   | environment_desc | TEXT |  | 否 | 寄养环境介绍 |
   | service_feature | VARCHAR | 255 | 否 | 服务特色 |
   | location | VARCHAR | 255 | 否 | 地理位置 |
   | latitude | DECIMAL | 10,8 | 否 | 纬度 |
   | longitude | DECIMAL | 11,8 | 否 | 经度 |
   | contact_info | VARCHAR | 255 | 否 | 联系方式 |
   | status | TINYINT | 1 | 否 | 服务状态（0：可用，1：不可用，2：已预订） |
   | create_time | DATETIME |  | 否 | 创建时间 |
   | update_time | DATETIME |  | 否 | 更新时间 |

4. 订单表（bookings）
   订单表用于存储用户预订寄养服务的订单信息。

   | 字段名 | 数据类型 | 长度 | 是否主键 | 描述 |
   |--------|----------|------|----------|------|
   | id | BIGINT | 20 | 是 | 订单ID |
   | order_no | VARCHAR | 50 | 否 | 订单编号 |
   | user_id | BIGINT | 20 | 否 | 用户ID（宠物主人ID） |
   | foster_user_id | BIGINT | 20 | 否 | 寄养家庭ID |
   | service_id | BIGINT | 20 | 否 | 寄养服务ID |
   | pet_id | BIGINT | 20 | 否 | 宠物ID |
   | start_date | DATE |  | 否 | 寄养开始日期 |
   | end_date | DATE |  | 否 | 寄养结束日期 |
   | total_days | INT | 11 | 否 | 寄养总天数 |
   | total_amount | DECIMAL | 10,2 | 否 | 订单总金额 |
   | payment_status | TINYINT | 1 | 否 | 支付状态（0：未支付，1：已支付，2：已退款） |
   | order_status | TINYINT | 1 | 否 | 订单状态（0：待支付，1：待接单，2：进行中，3：已完成，4：已取消，5：已退款） |
   | special_request | TEXT |  | 否 | 特殊需求 |
   | create_time | DATETIME |  | 否 | 创建时间 |
   | update_time | DATETIME |  | 否 | 更新时间 |
   | payment_time | DATETIME |  | 否 | 支付时间 |

5. 支付表（payments）
   支付表用于存储订单的支付记录。

   | 字段名 | 数据类型 | 长度 | 是否主键 | 描述 |
   |--------|----------|------|----------|------|
   | id | BIGINT | 20 | 是 | 支付ID |
   | order_id | BIGINT | 20 | 否 | 订单ID |
   | payment_no | VARCHAR | 50 | 否 | 支付流水号 |
   | payment_method | VARCHAR | 20 | 否 | 支付方式（如微信支付、支付宝） |
   | amount | DECIMAL | 10,2 | 否 | 支付金额 |
   | payment_status | TINYINT | 1 | 否 | 支付状态（0：未支付，1：已支付，2：支付失败，3：已退款） |
   | transaction_id | VARCHAR | 100 | 否 | 第三方交易ID |
   | create_time | DATETIME |  | 否 | 创建时间 |
   | update_time | DATETIME |  | 否 | 更新时间 |

6. 评价表（reviews）
   评价表用于存储用户对寄养服务的评价信息。

   | 字段名 | 数据类型 | 长度 | 是否主键 | 描述 |
   |--------|----------|------|----------|------|
   | id | BIGINT | 20 | 是 | 评价ID |
   | order_id | BIGINT | 20 | 否 | 订单ID |
   | user_id | BIGINT | 20 | 否 | 评价用户ID |
   | target_user_id | BIGINT | 20 | 否 | 被评价用户ID |
   | rating | TINYINT | 1 | 否 | 评分（1-5星） |
   | content | TEXT |  | 否 | 评价内容 |
   | create_time | DATETIME |  | 否 | 创建时间 |
   | update_time | DATETIME |  | 否 | 更新时间 |

7. 消息表（messages）
   消息表用于存储用户之间的消息记录。

   | 字段名 | 数据类型 | 长度 | 是否主键 | 描述 |
   |--------|----------|------|----------|------|
   | id | BIGINT | 20 | 是 | 消息ID |
   | sender_id | BIGINT | 20 | 否 | 发送者ID |
   | receiver_id | BIGINT | 20 | 否 | 接收者ID |
   | content | TEXT |  | 否 | 消息内容 |
   | is_read | TINYINT | 1 | 否 | 是否已读（0：未读，1：已读） |
   | create_time | DATETIME |  | 否 | 创建时间 |

8. 文件上传表（file_uploads）
   文件上传表用于存储用户上传的文件信息，如宠物照片、寄养环境照片等。

   | 字段名 | 数据类型 | 长度 | 是否主键 | 描述 |
   |--------|----------|------|----------|------|
   | id | BIGINT | 20 | 是 | 文件ID |
   | user_id | BIGINT | 20 | 否 | 用户ID |
   | file_name | VARCHAR | 255 | 否 | 文件名 |
   | file_path | VARCHAR | 255 | 否 | 文件路径 |
   | file_size | BIGINT | 20 | 否 | 文件大小（字节） |
   | file_type | VARCHAR | 50 | 否 | 文件类型（如image/jpeg） |
   | related_type | VARCHAR | 20 | 否 | 关联类型（如pet、service） |
   | related_id | BIGINT | 20 | 否 | 关联ID |
   | create_time | DATETIME |  | 否 | 创建时间 |

9. 审计日志表（audit_log）
   审计日志表用于存储系统的操作日志，便于问题追溯和安全审计。

   | 字段名 | 数据类型 | 长度 | 是否主键 | 描述 |
   |--------|----------|------|----------|------|
   | id | BIGINT | 20 | 是 | 日志ID |
   | user_id | BIGINT | 20 | 否 | 操作用户ID |
   | operation_type | VARCHAR | 50 | 否 | 操作类型（如login、create_order） |
   | operation_desc | VARCHAR | 255 | 否 | 操作描述 |
   | request_param | TEXT |  | 否 | 请求参数 |
   | response_result | TEXT |  | 否 | 响应结果 |
   | ip_address | VARCHAR | 50 | 否 | IP地址 |
   | user_agent | VARCHAR | 255 | 否 | 用户代理 |
   | create_time | DATETIME |  | 否 | 创建时间 |

### 4.1.3□索引设计

为了提高数据库的查询性能，需要为经常用于查询、排序、分组的字段创建索引。PetFosterHub宠物寄养平台的主要索引设计如下：

1. 用户表（users）索引：
   - 唯一索引：username、phone、email（用于快速查询和防止重复）
   - 普通索引：id_card_no、real_name、create_time（用于快速查询和排序）

2. 宠物表（pets）索引：
   - 普通索引：user_id（用于查询用户的所有宠物）、create_time（用于排序）

3. 寄养服务表（foster_services）索引：
   - 普通索引：user_id（用于查询用户发布的所有服务）、status（用于筛选可用服务）、start_time、end_time（用于时间范围查询）、location（用于地理位置查询）、create_time（用于排序）

4. 订单表（bookings）索引：
   - 普通索引：user_id（用于查询用户的所有订单）、foster_user_id（用于查询寄养家庭的所有订单）、service_id（用于查询服务的所有订单）、order_status（用于筛选订单状态）、create_time（用于排序）

5. 支付表（payments）索引：
   - 普通索引：order_id（用于查询订单的支付记录）、payment_status（用于筛选支付状态）、create_time（用于排序）

6. 评价表（reviews）索引：
   - 普通索引：order_id（用于查询订单的评价信息）、user_id（用于查询用户的评价记录）、target_user_id（用于查询用户收到的评价）、create_time（用于排序）

### 4.1.4□数据库优化

为了提高数据库的性能和可用性，需要采取一系列优化措施：

1. 数据库连接池：使用数据库连接池（如HikariCP）管理数据库连接，减少连接创建和关闭的开销。
2. SQL优化：编写高效的SQL语句，避免使用复杂的嵌套查询、全表扫描等，合理使用索引。
3. 分库分表：对于数据量较大的表，可以考虑进行分库分表，如按时间、按用户ID等进行分表。
4. 读写分离：采用主从复制的方式实现读写分离，提高数据库的并发处理能力。
5. 缓存机制：使用Redis缓存热点数据，减少数据库的访问压力。
6. 定期维护：定期进行数据库的备份、优化、碎片整理等维护工作。

## 4.2□系统模块实现

本节将详细介绍PetFosterHub宠物寄养平台各核心模块的实现过程，包括用户服务模块、宠物服务模块、寄养服务模块、订单服务模块、消息服务模块、支付服务模块、评价服务模块和搜索服务模块。

### 4.2.1□用户服务模块实现

用户服务模块是平台的基础模块，负责用户的注册、登录、个人信息管理、实名认证等功能。以下是该模块的主要实现代码：

1. UserController类（部分代码）：

```java
@RestController
@RequestMapping("/api/v1/users")
@Api(tags = "用户管理")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private AuthService authService;
    
    @PostMapping("/register")
    @ApiOperation("用户注册")
    public Result<Long> register(@Valid @RequestBody UserRegisterDTO userRegisterDTO) {
        Long userId = userService.register(userRegisterDTO);
        return Result.success(userId);
    }
    
    @PostMapping("/login")
    @ApiOperation("用户登录")
    public Result<LoginResultDTO> login(@Valid @RequestBody UserLoginDTO userLoginDTO) {
        LoginResultDTO loginResult = authService.login(userLoginDTO);
        return Result.success(loginResult);
    }
    
    @GetMapping("/profile")
    @ApiOperation("获取个人信息")
    @LoginRequired
    public Result<UserProfileDTO> getProfile() {
        Long userId = UserContext.getCurrentUserId();
        UserProfileDTO profile = userService.getProfile(userId);
        return Result.success(profile);
    }
    
    @PutMapping("/profile")
    @ApiOperation("更新个人信息")
    @LoginRequired
    public Result<Boolean> updateProfile(@Valid @RequestBody UserUpdateDTO userUpdateDTO) {
        Long userId = UserContext.getCurrentUserId();
        userService.updateProfile(userId, userUpdateDTO);
        return Result.success(true);
    }
    
    @PostMapping("/real-name-auth")
    @ApiOperation("提交实名认证")
    @LoginRequired
    public Result<Boolean> submitRealNameAuth(@Valid @RequestBody RealNameAuthDTO authDTO) {
        Long userId = UserContext.getCurrentUserId();
        userService.submitRealNameAuth(userId, authDTO);
        return Result.success(true);
    }
}
```

2. UserService类（部分代码）：

```java
@Service
public class UserServiceImpl implements UserService {
    
    @Autowired
    private UserMapper userMapper;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Override
    public Long register(UserRegisterDTO userRegisterDTO) {
        // 检查用户名、手机号、邮箱是否已存在
        checkUserExists(userRegisterDTO.getUsername(), userRegisterDTO.getPhone(), userRegisterDTO.getEmail());
        
        // 创建用户实体
        UserEntity userEntity = new UserEntity();
        userEntity.setUsername(userRegisterDTO.getUsername());
        // 密码加密
        userEntity.setPassword(passwordEncoder.encode(userRegisterDTO.getPassword()));
        userEntity.setPhone(userRegisterDTO.getPhone());
        userEntity.setEmail(userRegisterDTO.getEmail());
        userEntity.setNickname(userRegisterDTO.getNickname());
        userEntity.setGender(userRegisterDTO.getGender());
        userEntity.setBirthday(userRegisterDTO.getBirthday());
        userEntity.setRealNameStatus(RealNameStatus.NOT_AUTHENTICATED.getCode());
        userEntity.setStatus(UserStatus.NORMAL.getCode());
        userEntity.setCreateTime(new Date());
        userEntity.setUpdateTime(new Date());
        
        // 插入数据库
        userMapper.insert(userEntity);
        
        return userEntity.getId();
    }
    
    @Override
    public UserProfileDTO getProfile(Long userId) {
        UserEntity userEntity = userMapper.selectById(userId);
        if (userEntity == null) {
            throw new BusinessException(ErrorCode.USER_NOT_EXIST);
        }
        
        // 转换为DTO
        UserProfileDTO profileDTO = new UserProfileDTO();
        BeanUtils.copyProperties(userEntity, profileDTO);
        // 处理敏感信息，如身份证号脱敏
        if (StrUtil.isNotBlank(userEntity.getIdCardNo())) {
            profileDTO.setIdCardNo(DesensitizationUtil.idCard(userEntity.getIdCardNo()));
        }
        
        return profileDTO;
    }
    
    // 其他方法实现...
}
```

### 4.2.2□宠物服务模块实现

宠物服务模块负责宠物主人管理自己宠物的信息。以下是该模块的主要实现代码：

1. PetController类（部分代码）：

```java
@RestController
@RequestMapping("/api/v1/pets")
@Api(tags = "宠物管理")
public class PetController {
    
    @Autowired
    private PetService petService;
    
    @PostMapping
    @ApiOperation("添加宠物")
    @LoginRequired
    public Result<Long> addPet(@Valid @RequestBody PetAddDTO petAddDTO) {
        Long userId = UserContext.getCurrentUserId();
        Long petId = petService.addPet(userId, petAddDTO);
        return Result.success(petId);
    }
    
    @GetMapping("/{id}")
    @ApiOperation("获取宠物详情")
    @LoginRequired
    public Result<PetDetailDTO> getPetDetail(@PathVariable Long id) {
        Long userId = UserContext.getCurrentUserId();
        PetDetailDTO petDetail = petService.getPetDetail(userId, id);
        return Result.success(petDetail);
    }
    
    @GetMapping("/list")
    @ApiOperation("获取宠物列表")
    @LoginRequired
    public Result<PageResult<PetListDTO>> getPetList(@RequestParam(defaultValue = "1") Integer pageNum,
                                                   @RequestParam(defaultValue = "10") Integer pageSize) {
        Long userId = UserContext.getCurrentUserId();
        PageResult<PetListDTO> petList = petService.getPetList(userId, pageNum, pageSize);
        return Result.success(petList);
    }
    
    @PutMapping("/{id}")
    @ApiOperation("更新宠物信息")
    @LoginRequired
    public Result<Boolean> updatePet(@PathVariable Long id, @Valid @RequestBody PetUpdateDTO petUpdateDTO) {
        Long userId = UserContext.getCurrentUserId();
        petService.updatePet(userId, id, petUpdateDTO);
        return Result.success(true);
    }
    
    @DeleteMapping("/{id}")
    @ApiOperation("删除宠物")
    @LoginRequired
    public Result<Boolean> deletePet(@PathVariable Long id) {
        Long userId = UserContext.getCurrentUserId();
        petService.deletePet(userId, id);
        return Result.success(true);
    }
}
```

2. PetService类（部分代码）：

```java
@Service
public class PetServiceImpl implements PetService {
    
    @Autowired
    private PetMapper petMapper;
    
    @Autowired
    private FileUploadService fileUploadService;
    
    @Override
    public Long addPet(Long userId, PetAddDTO petAddDTO) {
        // 创建宠物实体
        PetEntity petEntity = new PetEntity();
        petEntity.setUserId(userId);
        petEntity.setName(petAddDTO.getName());
        petEntity.setType(petAddDTO.getType());
        petEntity.setBreed(petAddDTO.getBreed());
        petEntity.setAge(petAddDTO.getAge());
        petEntity.setGender(petAddDTO.getGender());
        petEntity.setWeight(petAddDTO.getWeight());
        petEntity.setPersonality(petAddDTO.getPersonality());
        petEntity.setHealthCondition(petAddDTO.getHealthCondition());
        petEntity.setVaccineStatus(petAddDTO.getVaccineStatus());
        petEntity.setDescription(petAddDTO.getDescription());
        petEntity.setCreateTime(new Date());
        petEntity.setUpdateTime(new Date());
        
        // 插入数据库
        petMapper.insert(petEntity);
        
        // 上传宠物照片
        if (CollUtil.isNotEmpty(petAddDTO.getPhotoUrls())) {
            fileUploadService.uploadPetPhotos(userId, petEntity.getId(), petAddDTO.getPhotoUrls());
        }
        
        return petEntity.getId();
    }
    
    @Override
    public PetDetailDTO getPetDetail(Long userId, Long petId) {
        PetEntity petEntity = petMapper.selectById(petId);
        if (petEntity == null) {
            throw new BusinessException(ErrorCode.PET_NOT_EXIST);
        }
        
        // 检查权限，确保用户只能查看自己的宠物
        if (!Objects.equals(petEntity.getUserId(), userId)) {
            throw new BusinessException(ErrorCode.NO_PERMISSION);
        }
        
        // 转换为DTO
        PetDetailDTO petDetailDTO = new PetDetailDTO();
        BeanUtils.copyProperties(petEntity, petDetailDTO);
        
        // 获取宠物照片列表
        List<String> photoUrls = fileUploadService.getPetPhotoUrls(petId);
        petDetailDTO.setPhotoUrls(photoUrls);
        
        return petDetailDTO;
    }
    
    // 其他方法实现...
}
```

### 4.2.3□寄养服务模块实现

寄养服务模块负责寄养家庭发布和管理寄养服务信息。以下是该模块的主要实现代码：

1. FosterServiceController类（部分代码）：

```java
@RestController
@RequestMapping("/api/v1/foster-services")
@Api(tags = "寄养服务管理")
public class FosterServiceController {
    
    @Autowired
    private FosterServiceService fosterServiceService;
    
    @PostMapping
    @ApiOperation("发布寄养服务")
    @LoginRequired
    public Result<Long> publishService(@Valid @RequestBody FosterServicePublishDTO publishDTO) {
        Long userId = UserContext.getCurrentUserId();
        Long serviceId = fosterServiceService.publishService(userId, publishDTO);
        return Result.success(serviceId);
    }
    
    @GetMapping("/{id}")
    @ApiOperation("获取寄养服务详情")
    public Result<FosterServiceDetailDTO> getServiceDetail(@PathVariable Long id) {
        FosterServiceDetailDTO serviceDetail = fosterServiceService.getServiceDetail(id);
        return Result.success(serviceDetail);
    }
    
    @GetMapping("/search")
    @ApiOperation("搜索寄养服务")
    public Result<PageResult<FosterServiceListDTO>> searchServices(
            @RequestParam(required = false) String keyword,
            @RequestParam(required = false) String serviceType,
            @RequestParam(required = false) String petType,
            @RequestParam(required = false) BigDecimal minPrice,
            @RequestParam(required = false) BigDecimal maxPrice,
            @RequestParam(defaultValue = "1") Integer pageNum,
            @RequestParam(defaultValue = "10") Integer pageSize) {
        
        FosterServiceSearchDTO searchDTO = new FosterServiceSearchDTO();
        searchDTO.setKeyword(keyword);
        searchDTO.setServiceType(serviceType);
        searchDTO.setPetType(petType);
        searchDTO.setMinPrice(minPrice);
        searchDTO.setMaxPrice(maxPrice);
        searchDTO.setPageNum(pageNum);
        searchDTO.setPageSize(pageSize);
        
        PageResult<FosterServiceListDTO> searchResult = fosterServiceService.searchServices(searchDTO);
        return Result.success(searchResult);
    }
    
    // 其他方法实现...
}
```

2. FosterServiceService类（部分代码）：

```java
@Service
public class FosterServiceServiceImpl implements FosterServiceService {
    
    @Autowired
    private FosterServiceMapper fosterServiceMapper;
    
    @Autowired
    private FileUploadService fileUploadService;
    
    @Autowired
    private ElasticsearchTemplate elasticsearchTemplate;
    
    @Override
    public Long publishService(Long userId, FosterServicePublishDTO publishDTO) {
        // 检查用户是否已实名认证
        checkUserRealNameAuth(userId);
        
        // 创建寄养服务实体
        FosterServiceEntity serviceEntity = new FosterServiceEntity();
        serviceEntity.setUserId(userId);
        serviceEntity.setServiceType(publishDTO.getServiceType());
        serviceEntity.setPrice(publishDTO.getPrice());
        serviceEntity.setStartTime(publishDTO.getStartTime());
        serviceEntity.setEndTime(publishDTO.getEndTime());
        serviceEntity.setMaxPetNum(publishDTO.getMaxPetNum());
        serviceEntity.setAcceptPetType(publishDTO.getAcceptPetType());
        serviceEntity.setEnvironmentDesc(publishDTO.getEnvironmentDesc());
        serviceEntity.setServiceFeature(publishDTO.getServiceFeature());
        serviceEntity.setLocation(publishDTO.getLocation());
        serviceEntity.setLatitude(publishDTO.getLatitude());
        serviceEntity.setLongitude(publishDTO.getLongitude());
        serviceEntity.setContactInfo(publishDTO.getContactInfo());
        serviceEntity.setStatus(ServiceStatus.AVAILABLE.getCode());
        serviceEntity.setCreateTime(new Date());
        serviceEntity.setUpdateTime(new Date());
        
        // 插入数据库
        fosterServiceMapper.insert(serviceEntity);
        
        // 上传寄养环境照片
        if (CollUtil.isNotEmpty(publishDTO.getPhotoUrls())) {
            fileUploadService.uploadServicePhotos(userId, serviceEntity.getId(), publishDTO.getPhotoUrls());
        }
        
        // 同步到Elasticsearch，用于搜索
        syncToElasticsearch(serviceEntity);
        
        return serviceEntity.getId();
    }
    
    @Override
    public PageResult<FosterServiceListDTO> searchServices(FosterServiceSearchDTO searchDTO) {
        // 构建Elasticsearch查询条件
        BoolQueryBuilder queryBuilder = QueryBuilders.boolQuery();
        
        // 关键词搜索
        if (StrUtil.isNotBlank(searchDTO.getKeyword())) {
            queryBuilder.must(QueryBuilders.multiMatchQuery(searchDTO.getKeyword(), "serviceFeature", "environmentDesc", "location"));
        }
        
        // 服务类型过滤
        if (StrUtil.isNotBlank(searchDTO.getServiceType())) {
            queryBuilder.filter(QueryBuilders.termQuery("serviceType", searchDTO.getServiceType()));
        }
        
        // 可接受宠物类型过滤
        if (StrUtil.isNotBlank(searchDTO.getPetType())) {
            queryBuilder.filter(QueryBuilders.termQuery("acceptPetType", searchDTO.getPetType()));
        }
        
        // 价格范围过滤
        if (searchDTO.getMinPrice() != null) {
            queryBuilder.filter(QueryBuilders.rangeQuery("price").gte(searchDTO.getMinPrice()));
        }
        if (searchDTO.getMaxPrice() != null) {
            queryBuilder.filter(QueryBuilders.rangeQuery("price").lte(searchDTO.getMaxPrice()));
        }
        
        // 服务状态过滤（只查询可用的服务）
        queryBuilder.filter(QueryBuilders.termQuery("status", ServiceStatus.AVAILABLE.getCode()));
        
        // 构建分页查询
        NativeSearchQuery searchQuery = new NativeSearchQueryBuilder()
                .withQuery(queryBuilder)
                .withPageable(PageRequest.of(searchDTO.getPageNum() - 1, searchDTO.getPageSize()))
                .withSort(SortBuilders.fieldSort("createTime").order(SortOrder.DESC))
                .build();
        
        // 执行查询
        Page<FosterServiceDocument> pageResult = elasticsearchTemplate.search(searchQuery, FosterServiceDocument.class);
        
        // 转换为DTO列表
        List<FosterServiceListDTO> listDTOs = pageResult.getContent().stream().map(document -> {
            FosterServiceListDTO listDTO = new FosterServiceListDTO();
            BeanUtils.copyProperties(document.getContent(), listDTO);
            return listDTO;
        }).collect(Collectors.toList());
        
        // 构建分页结果
        PageResult<FosterServiceListDTO> result = new PageResult<>();
        result.setList(listDTOs);
        result.setTotal(pageResult.getTotalElements());
        result.setPageNum(searchDTO.getPageNum());
        result.setPageSize(searchDTO.getPageSize());
        
        return result;
    }
    
    // 其他方法实现...
}
```

### 4.2.4□订单服务模块实现

订单服务模块负责宠物主人和寄养家庭之间的订单交易流程。以下是该模块的主要实现代码：

1. OrderController类（部分代码）：

```java
@RestController
@RequestMapping("/api/v1/orders")
@Api(tags = "订单管理")
public class OrderController {
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private PaymentService paymentService;
    
    @PostMapping
    @ApiOperation("创建订单")
    @LoginRequired
    public Result<Long> createOrder(@Valid @RequestBody OrderCreateDTO orderCreateDTO) {
        Long userId = UserContext.getCurrentUserId();
        Long orderId = orderService.createOrder(userId, orderCreateDTO);
        return Result.success(orderId);
    }
    
    @PostMapping("/{id}/pay")
    @ApiOperation("支付订单")
    @LoginRequired
    public Result<PaymentInfoDTO> payOrder(@PathVariable Long id, @Valid @RequestBody PaymentRequestDTO paymentRequestDTO) {
        Long userId = UserContext.getCurrentUserId();
        PaymentInfoDTO paymentInfo = paymentService.payOrder(userId, id, paymentRequestDTO);
        return Result.success(paymentInfo);
    }
    
    @GetMapping("/{id}")
    @ApiOperation("获取订单详情")
    @LoginRequired
    public Result<OrderDetailDTO> getOrderDetail(@PathVariable Long id) {
        Long userId = UserContext.getCurrentUserId();
        OrderDetailDTO orderDetail = orderService.getOrderDetail(userId, id);
        return Result.success(orderDetail);
    }
    
    @GetMapping("/list")
    @ApiOperation("获取订单列表")
    @LoginRequired
    public Result<PageResult<OrderListDTO>> getOrderList(
            @RequestParam(required = false) Integer orderStatus,
            @RequestParam(defaultValue = "1") Integer pageNum,
            @RequestParam(defaultValue = "10") Integer pageSize) {
        
        Long userId = UserContext.getCurrentUserId();
        PageResult<OrderListDTO> orderList = orderService.getOrderList(userId, orderStatus, pageNum, pageSize);
        return Result.success(orderList);
    }
    
    // 其他方法实现...
}
```

2. OrderService类（部分代码）：

```java
@Service
public class OrderServiceImpl implements OrderService {
    
    @Autowired
    private OrderMapper orderMapper;
    
    @Autowired
    private FosterServiceMapper fosterServiceMapper;
    
    @Autowired
    private PetMapper petMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Override
    @Transactional
    public Long createOrder(Long userId, OrderCreateDTO orderCreateDTO) {
        // 获取寄养服务信息
        FosterServiceEntity serviceEntity = fosterServiceMapper.selectById(orderCreateDTO.getServiceId());
        if (serviceEntity == null) {
            throw new BusinessException(ErrorCode.FOSTER_SERVICE_NOT_EXIST);
        }
        
        // 检查服务是否可用
        if (!Objects.equals(serviceEntity.getStatus(), ServiceStatus.AVAILABLE.getCode())) {
            throw new BusinessException(ErrorCode.FOSTER_SERVICE_NOT_AVAILABLE);
        }
        
        // 获取宠物信息
        PetEntity petEntity = petMapper.selectById(orderCreateDTO.getPetId());
        if (petEntity == null) {
            throw new BusinessException(ErrorCode.PET_NOT_EXIST);
        }
        
        // 检查宠物是否属于用户
        if (!Objects.equals(petEntity.getUserId(), userId)) {
            throw new BusinessException(ErrorCode.NO_PERMISSION);
        }
        
        // 计算寄养天数和总金额
        long days = DateUtil.betweenDay(orderCreateDTO.getStartDate(), orderCreateDTO.getEndDate(), false) + 1;
        BigDecimal totalAmount = serviceEntity.getPrice().multiply(new BigDecimal(days));
        
        // 生成订单编号
        String orderNo = OrderNoGenerator.generate();
        
        // 创建订单实体
        OrderEntity orderEntity = new OrderEntity();
        orderEntity.setOrderNo(orderNo);
        orderEntity.setUserId(userId);
        orderEntity.setFosterUserId(serviceEntity.getUserId());
        orderEntity.setServiceId(serviceEntity.getId());
        orderEntity.setPetId(petEntity.getId());
        orderEntity.setStartDate(orderCreateDTO.getStartDate());
        orderEntity.setEndDate(orderCreateDTO.getEndDate());
        orderEntity.setTotalDays((int) days);
        orderEntity.setTotalAmount(totalAmount);
        orderEntity.setPaymentStatus(PaymentStatus.UNPAID.getCode());
        orderEntity.setOrderStatus(OrderStatus.WAITING_FOR_PAYMENT.getCode());
        orderEntity.setSpecialRequest(orderCreateDTO.getSpecialRequest());
        orderEntity.setCreateTime(new Date());
        orderEntity.setUpdateTime(new Date());
        
        // 插入数据库
        orderMapper.insert(orderEntity);
        
        // 设置订单过期时间（例如30分钟后自动取消）
        String redisKey = "order:expire:" + orderEntity.getId();
        redisTemplate.opsForValue().set(redisKey, orderEntity.getId(), 30, TimeUnit.MINUTES);
        
        return orderEntity.getId();
    }
    
    @Override
    public OrderDetailDTO getOrderDetail(Long userId, Long orderId) {
        OrderEntity orderEntity = orderMapper.selectById(orderId);
        if (orderEntity == null) {
            throw new BusinessException(ErrorCode.ORDER_NOT_EXIST);
        }
        
        // 检查权限，确保用户只能查看自己的订单
        if (!Objects.equals(orderEntity.getUserId(), userId) && !Objects.equals(orderEntity.getFosterUserId(), userId)) {
            throw new BusinessException(ErrorCode.NO_PERMISSION);
        }
        
        // 转换为DTO
        OrderDetailDTO orderDetailDTO = new OrderDetailDTO();
        BeanUtils.copyProperties(orderEntity, orderDetailDTO);
        
        // 获取寄养服务信息
        FosterServiceEntity serviceEntity = fosterServiceMapper.selectById(orderEntity.getServiceId());
        if (serviceEntity != null) {
            orderDetailDTO.setServiceName(serviceEntity.getServiceType() + " - " + serviceEntity.getLocation());
            orderDetailDTO.setServicePrice(serviceEntity.getPrice());
        }
        
        // 获取宠物信息
        PetEntity petEntity = petMapper.selectById(orderEntity.getPetId());
        if (petEntity != null) {
            orderDetailDTO.setPetName(petEntity.getName());
            orderDetailDTO.setPetType(petEntity.getType());
        }
        
        return orderDetailDTO;
    }
    
    // 其他方法实现...
}
```

## 4.3□接口设计

接口设计是系统前后端交互的桥梁，合理的接口设计可以提高系统的可维护性和扩展性。PetFosterHub宠物寄养平台的接口设计遵循RESTful API设计规范，主要包括用户接口、宠物接口、寄养服务接口、订单接口、支付接口、消息接口和评价接口等。

### 4.3.1□接口设计原则

在接口设计过程中，遵循以下设计原则：

1. RESTful设计：使用HTTP方法（GET、POST、PUT、DELETE等）表示操作类型，使用URL表示资源，使用HTTP状态码表示响应状态。
2. 统一响应格式：所有接口的响应都采用统一的格式，包含状态码、消息、数据等字段。
3. 版本控制：接口采用版本控制，便于后续的接口升级和兼容性管理。
4. 参数校验：对接口的输入参数进行严格的校验，确保数据的有效性和安全性。
5. 错误处理：提供友好的错误提示和详细的错误信息，便于前端开发人员和用户理解。
6. 文档化：使用Swagger/OpenAPI对接口进行文档化，方便前端开发人员和测试人员了解和使用接口。

### 4.3.2□统一响应格式

PetFosterHub宠物寄养平台的所有接口都采用统一的响应格式，示例如下：

```json
{
  "code": 0,
  "message": "success",
  "data": {
    // 具体的响应数据
  }
}
```

其中，各字段的含义如下：
- code：状态码，0表示成功，其他值表示失败。
- message：响应消息，成功时为"success"，失败时为具体的错误信息。
- data：响应数据，成功时为具体的业务数据，失败时可能为null。

### 4.3.3□主要接口列表

以下是PetFosterHub宠物寄养平台的主要接口列表：

1. 用户接口：
   - POST /api/v1/users/register：用户注册
   - POST /api/v1/users/login：用户登录
   - GET /api/v1/users/profile：获取个人信息
   - PUT /api/v1/users/profile：更新个人信息
   - POST /api/v1/users/real-name-auth：提交实名认证

2. 宠物接口：
   - POST /api/v1/pets：添加宠物
   - GET /api/v1/pets/{id}：获取宠物详情
   - GET /api/v1/pets/list：获取宠物列表
   - PUT /api/v1/pets/{id}：更新宠物信息
   - DELETE /api/v1/pets/{id}：删除宠物

3. 寄养服务接口：
   - POST /api/v1/foster-services：发布寄养服务
   - GET /api/v1/foster-services/{id}：获取寄养服务详情
   - GET /api/v1/foster-services/search：搜索寄养服务
   - PUT /api/v1/foster-services/{id}：更新寄养服务信息
   - DELETE /api/v1/foster-services/{id}：删除寄养服务

4. 订单接口：
   - POST /api/v1/orders：创建订单
   - POST /api/v1/orders/{id}/pay：支付订单
   - GET /api/v1/orders/{id}：获取订单详情
   - GET /api/v1/orders/list：获取订单列表
   - PUT /api/v1/orders/{id}/cancel：取消订单

5. 支付接口：
   - POST /api/v1/payments/{id}/callback：支付回调
   - GET /api/v1/payments/{id}/status：查询支付状态

6. 消息接口：
   - GET /api/v1/messages/list：获取消息列表
   - PUT /api/v1/messages/{id}/read：标记消息已读
   - POST /api/v1/messages/send：发送消息

7. 评价接口：
   - POST /api/v1/reviews：发布评价
   - GET /api/v1/reviews/{id}：获取评价详情
   - GET /api/v1/reviews/list：获取评价列表

## 4.4□关键算法实现

PetFosterHub宠物寄养平台在实现过程中涉及到一些关键算法，如地理位置搜索算法、推荐算法、订单号生成算法等。本节将对这些关键算法进行详细介绍。

### 4.4.1□地理位置搜索算法

地理位置搜索是寄养服务搜索的重要功能，用户可以根据自己的位置查找附近的寄养服务。地理位置搜索算法的实现主要基于经纬度计算，具体步骤如下：

1. 获取用户的当前经纬度（latitude, longitude）。
2. 计算用户当前位置与每个寄养服务位置之间的距离。距离的计算公式如下：
   
   ```
   distance = 2 * R * asin(sqrt(sin²((lat2-lat1)/2) + cos(lat1) * cos(lat2) * sin²((lon2-lon1)/2)))
   ```
   
   其中，R是地球半径（约6371公里），lat1、lon1是用户的经纬度，lat2、lon2是寄养服务的经纬度。
3. 根据距离进行排序，返回距离用户最近的寄养服务列表。

在实际实现中，可以利用数据库的空间索引或Elasticsearch的地理位置功能来优化地理位置搜索的性能。例如，在Elasticsearch中，可以使用GeoDistanceQuery来实现地理位置搜索，示例代码如下：

```java
// 构建地理位置查询
GeoDistanceQueryBuilder geoQuery = QueryBuilders.geoDistanceQuery("location")
        .point(userLat, userLon)
        .distance(searchDistance, DistanceUnit.KILOMETERS);

// 将地理位置查询添加到主查询中
BoolQueryBuilder queryBuilder = QueryBuilders.boolQuery();
queryBuilder.filter(geoQuery);
```

### 4.4.2□推荐算法

为了提高用户体验和平台的转化率，PetFosterHub宠物寄养平台实现了推荐算法，为用户推荐可能感兴趣的寄养服务。推荐算法的实现主要基于协同过滤和内容推荐，具体步骤如下：

1. 收集用户行为数据，如浏览历史、收藏历史、订单历史等。
2. 分析用户的偏好，如偏好的服务类型、价格范围、地理位置等。
3. 基于用户的偏好和行为数据，计算用户与寄养服务之间的相似度。
4. 根据相似度进行排序，为用户推荐相似度最高的寄养服务。

在实际实现中，可以使用机器学习算法来优化推荐效果，如使用矩阵分解、深度学习等算法。同时，可以结合实时推荐和离线推荐两种方式，提高推荐的实时性和准确性。

### 4.4.3□订单号生成算法

订单号是订单的唯一标识，需要保证唯一性和安全性。PetFosterHub宠物寄养平台的订单号生成算法采用时间戳+随机数+用户ID的方式，具体步骤如下：

1. 获取当前时间戳（精确到毫秒）。
2. 生成一个随机数（如6位随机数）。
3. 获取用户ID的后几位（如4位）。
4. 将时间戳、随机数、用户ID的后几位组合成订单号。

示例代码如下：

```java
public class OrderNoGenerator {
    
    private static final Random random = new Random();
    
    public static String generate() {
        // 获取当前时间戳（精确到毫秒）
        String timestamp = String.valueOf(System.currentTimeMillis());
        
        // 生成6位随机数
        String randomNum = String.format("%06d", random.nextInt(1000000));
        
        // 组合成订单号
        String orderNo = timestamp + randomNum;
        
        return orderNo;
    }
    
    // 带用户ID的订单号生成
    public static String generateWithUserId(Long userId) {
        String timestamp = String.valueOf(System.currentTimeMillis());
        String randomNum = String.format("%06d", random.nextInt(1000000));
        
        // 获取用户ID的后4位，如果用户ID不足4位，则在前面补0
        String userIdSuffix = String.format("%04d", userId % 10000);
        
        String orderNo = timestamp + randomNum + userIdSuffix;
        
        return orderNo;
    }
}
```

## 4.5□系统集成与测试

系统集成与测试是确保系统质量和可靠性的重要环节。PetFosterHub宠物寄养平台的系统集成与测试包括单元测试、集成测试、接口测试、性能测试和安全测试等方面。

### 4.5.1□单元测试

单元测试是对系统的最小功能单元（如方法、函数）进行测试，确保每个单元都能正常工作。PetFosterHub宠物寄养平台的单元测试主要使用JUnit和Mockito框架，测试范围包括：

1. 服务层方法的业务逻辑。
2. 数据访问层的CRUD操作。
3. 工具类和辅助方法的功能。

示例单元测试代码如下：

```java
@SpringBootTest
public class UserServiceTest {
    
    @Autowired
    private UserService userService;
    
    @MockBean
    private UserMapper userMapper;
    
    @Test
    public void testRegister() {
        // 准备测试数据
        UserRegisterDTO registerDTO = new UserRegisterDTO();
        registerDTO.setUsername("testuser");
        registerDTO.setPassword("123456");
        registerDTO.setPhone("13800138000");
        registerDTO.setEmail("test@example.com");
        registerDTO.setNickname("测试用户");
        
        // 模拟UserMapper的行为
        UserEntity userEntity = new UserEntity();
        userEntity.setId(1L);
        when(userMapper.insert(any(UserEntity.class))).thenReturn(1);
        when(userMapper.selectByUsername(anyString())).thenReturn(null);
        when(userMapper.selectByPhone(anyString())).thenReturn(null);
        when(userMapper.selectByEmail(anyString())).thenReturn(null);
        
        // 执行测试
        Long userId = userService.register(registerDTO);
        
        // 验证结果
        Assert.assertEquals(1L, userId.longValue());
        verify(userMapper).insert(any(UserEntity.class));
    }
}
```

### 4.5.2□集成测试

集成测试是对系统的多个组件或模块进行测试，确保它们之间的交互和集成能够正常工作。PetFosterHub宠物寄养平台的集成测试主要使用Spring Boot Test框架，测试范围包括：

1. 控制器层与服务层的集成。
2. 服务层与数据访问层的集成。
3. 多个服务之间的集成。

示例集成测试代码如下：

```java
@SpringBootTest
@AutoConfigureMockMvc
public class UserControllerIT {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Test
    public void testRegister() throws Exception {
        // 准备测试数据
        UserRegisterDTO registerDTO = new UserRegisterDTO();
        registerDTO.setUsername("testuser2");
        registerDTO.setPassword("123456");
        registerDTO.setPhone("13800138001");
        registerDTO.setEmail("test2@example.com");
        registerDTO.setNickname("测试用户2");
        
        // 执行HTTP请求
        MvcResult result = mockMvc.perform(post("/api/v1/users/register")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(registerDTO)))
                .andExpect(status().isOk())
                .andReturn();
        
        // 验证响应结果
        String responseContent = result.getResponse().getContentAsString();
        Result<Long> response = objectMapper.readValue(responseContent, new TypeReference<Result<Long>>() {});
        Assert.assertEquals(0, response.getCode());
        Assert.assertNotNull(response.getData());
    }
}
```

### 4.5.3□接口测试

接口测试是对系统的API接口进行测试，确保接口的功能、性能和安全性符合要求。PetFosterHub宠物寄养平台的接口测试主要使用Postman工具，测试范围包括：

1. 接口的功能正确性。
2. 接口的参数校验。
3. 接口的错误处理。
4. 接口的认证和授权。

接口测试的主要步骤包括：

1. 创建测试用例，包括请求URL、请求方法、请求参数、请求头、预期响应等。
2. 执行测试用例，发送HTTP请求。
3. 验证响应结果，包括状态码、响应消息、响应数据等。
4. 生成测试报告，记录测试结果和问题。

### 4.5.4□性能测试

性能测试是对系统的性能进行测试，确保系统在高并发、大数据量的情况下能够正常工作。PetFosterHub宠物寄养平台的性能测试主要使用JMeter工具，测试范围包括：

1. 系统的响应时间。
2. 系统的吞吐量。
3. 系统的并发处理能力。
4. 系统的资源利用率（如CPU、内存、数据库连接等）。

性能测试的主要步骤包括：

1. 设计性能测试场景，如用户登录、搜索寄养服务、创建订单等。
2. 配置测试参数，如并发用户数、测试持续时间、思考时间等。
3. 执行性能测试，模拟多用户并发访问系统。
4. 监控系统性能指标，如响应时间、吞吐量、资源利用率等。
5. 分析测试结果，找出性能瓶颈，提出优化建议。

### 4.5.5□安全测试

安全测试是对系统的安全性进行测试，确保系统能够抵御各种安全威胁。PetFosterHub宠物寄养平台的安全测试主要包括：

1. 认证和授权测试：测试用户认证、权限控制等功能是否正常工作。
2. 数据安全测试：测试数据加密、数据脱敏、数据备份等功能是否正常工作。
3. 接口安全测试：测试接口的参数校验、SQL注入、XSS攻击、CSRF攻击等防护措施是否有效。
4. 网络安全测试：测试HTTPS传输、网络隔离等措施是否有效。

安全测试的主要步骤包括：

1. 设计安全测试用例，如尝试未授权访问、注入攻击、跨站脚本攻击等。
2. 执行安全测试，模拟各种安全威胁。
3. 分析测试结果，找出安全漏洞，提出修复建议。
4. 验证修复效果，确保安全漏洞得到有效修复。

通过以上的系统设计与实现，可以看出PetFosterHub宠物寄养平台的系统架构合理、技术选型适当、模块实现完整、接口设计规范、算法实现高效、测试覆盖全面，能够满足系统的功能需求和非功能需求，为用户提供安全、稳定、高效的宠物寄养服务。